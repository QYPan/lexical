#if 0

传统操作系统：进程肩负 资源分配单位 和 调度运行单位
                       ------------    ------------
现在把调度运行的职责赋予新的实体 ———— 线程

引入原因：
1.使并行实体获得共享同一地址空间和所有可用数据的能力
2.易于切换，代价低
3.可以改善系统性能

线程的实现方式
--------------

用户级线程，核心级线程

进程间的相互关系
----------------

1.互斥 : 进程彼此不知对方存在，逻辑上没有关系，由于竞争同一资源而发生相互
         制约，涉及竞争条件与临界区
2.同步 : 进程彼此不知道对方的名字，但通过对某些对象(如 I/O 缓冲区)的共同
         存取协同完成一项任务，时间次序上有约束
3.通信 : 进程彼此可以通过名字直接进行通信，交换信息，时间次序上无约束

实现互斥的方式
--------------

1.硬件方法，不谈。。。
2.原语操作 : 也称原子操作，指一个操作要么全做，要么不做，不可中断
3.利用软件 : 上锁，缺点：只要有一个进程进入临界区，并上锁，其他进程将反复
             执行 lock 原语检查锁的状态，造成处理机“忙等”

信号量 P, V 操作原语

生产者消费者问题
-----------------

full : 表示存有产品的缓冲数，初始值为 0
empty : 表示可供使用的缓冲区数，初始值为 N
mutex : 互斥信号量，初始值为 1

Producer:                          Consumer:
while(true){                       while(true){
	P(empty);					       P(full);
	P(mutex);                          P(mutex);
	buffer(in);                        buffer(out);
	in = (in + 1) mod N;               out = (out + 1) mod N;
	V(mutex);                          V(mutex);
	V(full);                           V(empty);
}                                  }

两个 P 操作顺序不能颠倒，否则可能造成死锁 !!!
假如 Producer 和 Consumer 的两个 P 操作都调换，设想生产者已经将缓冲区放满，
消费者并没有取产品，当下次仍然是生产者运行时，它先执行 P(mutex) 封锁信号量，
再执行 P(empty) 时被阻塞，希望消费者取出产品后将其唤醒；轮到消费者运行时，
它先执行 P(mutex)，然而由于生产者已经封锁 mutex 信号量，消费者也会被阻塞。
所以不能互换顺序，释放信号量时则先释放哪个都可以

进程间通信
----------

共享存储器，管道文件，消息传递(send, receive)

#endif
